<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Z-Axis Tracking Prototype</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; }
        canvas { display: block; }
        #loading {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white; font-family: sans-serif;
            pointer-events: none;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 4px;
            user-select: none;
        }
    </style>
    <!-- Import Map: Essential for GLTFLoader to resolve 'three' internally -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loading">Loading Model...</div>

    <script type="module">
        // UPDATED: Using full URLs here bypasses Vite's local package resolution logic,
        // preventing errors if you haven't run 'npm install three'.
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
        import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';

        // 1. Scene Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);

        // Camera setup
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 4; // Move camera back to see the model

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 1);
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(2, 5, 5);
        scene.add(dirLight);

        // 2. Logic Variables
        let model;
        let pivot; // Container group for rotation adjustments
        const mouse = new THREE.Vector2();
        const targetPos = new THREE.Vector3();
        const raycaster = new THREE.Raycaster();
        
        // Create an invisible plane to catch the mouse ray
        const planeGeo = new THREE.PlaneGeometry(20, 20);
        const planeMat = new THREE.MeshBasicMaterial({ visible: false }); 
        const mousePlane = new THREE.Mesh(planeGeo, planeMat);
        
        // ROTATION SENSITIVITY FIX: 
        // Move the plane much closer to the center (Z=0.5).
        // The closer this plane is to the pivot (0,0,0), the wider the angle 
        // the model will have to turn to look at the intersection point.
        mousePlane.position.z = 0.5; 
        scene.add(mousePlane);

        // Create a Pivot Group
        // We lookAt with the Pivot, but rotate the Model inside it.
        pivot = new THREE.Group();
        pivot.position.set(0, 0, 0);
        scene.add(pivot);

        // 3. Load the GLB Model
        const loader = new GLTFLoader();
        // Using the URL provided in your code
        const url = 'https://storage.googleapis.com/skanz-art-assets/quickstart-folder/NPChar-head.glb';

        loader.load(url, (gltf) => {
            model = gltf.scene;
            
            // Center the model in the pivot
            model.position.set(0, 0, 0); 
            
            // Note: Positive Z-axis faces the mouse cursor (default behavior).
            // No extra rotation is applied here.

            // Add model to pivot instead of scene directly
            pivot.add(model);
            
            // Hide loading text
            document.getElementById('loading').style.display = 'none';

        }, undefined, (error) => {
            console.error('An error happened:', error);
            document.getElementById('loading').textContent = 'Error loading model.';
        });

        // 4. Mouse Event Listener
        window.addEventListener('mousemove', (event) => {
            // Normalize mouse coordinates to -1 to +1
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 5. Animation Loop
        function animate() {
            requestAnimationFrame(animate);

            // Logic: Cast a ray from camera through mouse position
            raycaster.setFromCamera(mouse, camera);

            // Find where the ray hits our invisible plane
            const intersects = raycaster.intersectObject(mousePlane);

            if (intersects.length > 0 && model) {
                // Get the point in 3D space where the mouse is hovering
                const point = intersects[0].point;
                
                // SMOOTHING (Linear Interpolation)
                targetPos.lerp(point, 0.1);

                // Pivot looks at the target. 
                pivot.lookAt(targetPos);
            }

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>